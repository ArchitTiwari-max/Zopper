// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  EXECUTIVE
}


model User {
  id        String   @id @map("_id")
  email     String   @unique
  username  String   @unique
  password  String
  role      Role     @default(EXECUTIVE)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  executive Executive?
  admin     Admin?
  dostChats DostChat[]

  @@map("User")
}

model Admin {
  id             String  @id @map("_id")
  name           String
  contact_number String
  region         String?
  userId         String  @unique
  user           User    @relation(fields: [userId], references: [id])

  // Back-relations: visits reviewed by this admin
  reviewedVisits        Visit[]
  reviewedDigitalVisits DigitalVisit[]
}

model Executive {
  id              String                     @id @map("_id")
  name            String
  contact_number  String
  region          String?
  visits          Visit[]
  digitalVisits   DigitalVisit[]
  assigned        Assigned[]
  visitPlans      VisitPlan[]
  userId          String                     @unique
  user            User                       @relation(fields: [userId], references: [id])
  // Store assignments
  executiveStores ExecutiveStoreAssignment[]
  // Dost chat back-relation
  dostChats       DostChat[]
}

//
// Store & Brand 
//

// Brand type classification for partner brands associated to a store
enum PartnerBrandType {
  A_PLUS @map("A+")
  A
  B
  C
  D
}

model Store {
  id                String                      @id @map("_id") 
  storeName         String
  city              String
  fullAddress       String?
  visits            Visit[]
  digitalVisits     DigitalVisit[]
  partnerBrandIds   String[]                    // references Brand IDs
  partnerBrandTypes PartnerBrandType[] // parallel array corresoponding to same index in partnerBrandIds
  executiveStores   ExecutiveStoreAssignment[]
  salesRecords      SalesRecord[]
}

model ExecutiveStoreAssignment {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  executiveId String
  storeId     String
  assignedAt  DateTime @default(now())

  executive Executive @relation(fields: [executiveId], references: [id])
  store     Store     @relation(fields: [storeId], references: [id])

  @@unique([executiveId, storeId])
}

model Brand {
  id           String          @id @map("_id")
  brandName    String          @unique
  categories   CategoryBrand[]
  salesRecords SalesRecord[]
}

model Category {
  id            String           @id @map("_id")
  categoryName  String          @unique
  brands        CategoryBrand[]
  salesRecords  SalesRecord[]
  
  // Index for better performance when searching by category name
}

model CategoryBrand {
  id         String @id @map("_id")
  brandId    String
  categoryId String

  brand    Brand    @relation(fields: [brandId], references: [id])
  category Category @relation(fields: [categoryId], references: [id])

  @@unique([brandId, categoryId])
}


model SalesRecord {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  storeId     String
  brandId     String
  categoryId  String
  year        Int

  // Store summary of all 12 months
  // Each month contains deviceSales, planSales, attachPct, revenue etc.
  monthlySales Json // [{ month: 1, deviceSales: X, planSales: Y, attachPct: Z, revenue: R }, ..., { month: 12, ... }]

  // Store all daily sales grouped by month
  // ⚠️ Daily sales only tracks planSales and revenue for each day
  // Example:
  // {
  //   "1": [
  //     { "date": "01-01-2025", "planSales": 1, "revenue": 1200 },
  //     { "date": "02-01-2025", "planSales": 2, "revenue": 2100 }
  //   ],
  //   "2": [
  //     { "date": "01-02-2025", "planSales": 1, "revenue": 900 }
  //   ],
  //   ...
  // }
  dailySales   Json 

  store     Store     @relation(fields: [storeId], references: [id])
  brand     Brand     @relation(fields: [brandId], references: [id])
  category  Category  @relation(fields: [categoryId], references: [id])

  @@unique([storeId, brandId, categoryId, year])

  // Indexes for faster analytics queries
  @@index([storeId, year])
  @@index([brandId, categoryId, year])
}

//
// Visit & Issue
//

enum viststatus {
  PENDING_REVIEW
  REVIEWD
}

model Visit {
  id                String     @id @default(auto()) @map("_id") @db.ObjectId
  personMet         Json // [{ name: "Rajesh", designation: "Manager", phoneNumber: "1234567890" }]
  POSMchecked       Boolean?   @map("displayChecked") // Point of Sale Material availability check (nullable for backward compatibility)
  remarks           String?
  imageUrls         String[] // Array of image URLs
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt
  status            viststatus @default(PENDING_REVIEW)
  adminComment      String?
  reviewedAt        DateTime?
  reviewedByAdminId String?
  reviewedByAdmin   Admin?     @relation(fields: [reviewedByAdminId], references: [id])
  // relations
  executiveId       String
  executive         Executive  @relation(fields: [executiveId], references: [id])

  storeId  String
  store    Store    @relation(fields: [storeId], references: [id])
  brandIds String[]

  issues        Issue[] // One Visit can have multiple Issues or none
  notifications Notification[] // Notifications related to this visit

  // Critical performance indexes based on actual queries
  @@index([executiveId, createdAt])
  @@index([storeId])
}

enum IssueStatus {
  Pending
  Assigned
  Resolved
}

model Issue {
  id        String      @id @map("_id")
  details   String
  createdBy Role?       @default(EXECUTIVE) // Who created the issue: ADMIN or EXECUTIVE
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  status    IssueStatus @default(Pending)

  // relations to either Physical Visit or Digital Visit
  visitId        String?     @db.ObjectId
  visit          Visit?      @relation(fields: [visitId], references: [id])
  digitalVisitId String?     @db.ObjectId
  digitalVisit   DigitalVisit? @relation(fields: [digitalVisitId], references: [id])

  assigned  Assigned[]  // One Issue can have multiple Assigned records
  notifications Notification[] // Notifications related to this issue
  
  // Critical performance indexes based on actual queries
  @@index([visitId])
  @@index([digitalVisitId])
}

enum AssignedStatus {
  Assigned
  In_Progress
  Completed
}

model Assigned {
  id           String         @id @default(auto()) @map("_id") @db.ObjectId
  adminComment String?
  createdAt    DateTime       @default(now())
  status       AssignedStatus @default(Assigned)

  // relation to Issue
  issueId String
  issue   Issue  @relation(fields: [issueId], references: [id])

  // relation to Executive
  executiveId String
  executive   Executive @relation(fields: [executiveId], references: [id])

  // relation to AssignReport
  assignReport  AssignReport?
  notifications Notification[] // Notifications related to this assignment

  // Critical performance indexes based on actual queries
  @@index([executiveId, status])
}

model AssignReport {
  id                   String   @id @default(auto()) @map("_id") @db.ObjectId
  remarks              String // Required field
  personMetName        String? // Optional field
  personMetDesignation String? // Optional field
  photoUrls            String[] // Array of photo URLs (optional)
  createdAt            DateTime @default(now())

  // relation to Assigned task
  assignedId String   @unique @db.ObjectId
  assigned   Assigned @relation(fields: [assignedId], references: [id], onDelete: Cascade)

  @@map("AssignReport")
}

//
// Digital Visit (separate lightweight schema for remote connects)
//

model DigitalVisit {
  id               String       @id @default(auto()) @map("_id") @db.ObjectId
  connectDate      DateTime     // date of call/connect
  personMet        Json         // [{ name, designation, phoneNumber }]
  remarks          String       // required remarks for digital visit
  status           viststatus   @default(PENDING_REVIEW)
  adminComment     String?
  reviewedAt       DateTime?
  reviewedByAdminId String?
  reviewedByAdmin  Admin?       @relation(fields: [reviewedByAdminId], references: [id])

  executiveId String
  executive   Executive    @relation(fields: [executiveId], references: [id])

  storeId String
  store   Store       @relation(fields: [storeId], references: [id])

  issues  Issue[]

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([executiveId, connectDate])
  @@index([storeId])
}

//
// Visit Plan (PJP)
//

enum VisitPlanStatus {
  SUBMITTED
  COMPLETED
}

model VisitPlan {
  id               String          @id @default(auto()) @map("_id") @db.ObjectId
  executiveId      String
  executive        Executive       @relation(fields: [executiveId], references: [id])
  storeIds         String[]
  storesSnapshot   Json? // Optional snapshot of store details at submission time
  status           VisitPlanStatus @default(SUBMITTED)
  submittedAt      DateTime        @default(now())
  reviewedAt       DateTime?
  reviewNote       String?
  plannedVisitDate DateTime // The date when visits should be conducted

  // Timestamps for better caching
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Admin creation support
  createdByAdminId String? // Admin ID who created this plan (null for executive-created)
  adminComment     String? // Comment from admin when creating the plan
  createdByRole    Role    @default(EXECUTIVE) // ADMIN or EXECUTIVE

  // Notifications related to this plan
  notifications Notification[]

  @@index([executiveId, submittedAt])
  @@index([createdByAdminId, submittedAt])
  @@map("VisitPlan")
}

model OTP {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  email     String
  otp       String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("Otp")
}

//
// Notification System
//

enum NotificationType {
  VISIT_SUBMITTED // Executive submits a visit -> Admin
  VISIT_REVIEWED // Admin reviews a visit -> Executive  
  ISSUE_REPORTED // Executive reports an issue -> Admin
  ISSUE_ASSIGNED // Admin assigns issue -> Executive
  ISSUE_STATUS_UPDATED // Executive updates issue status -> Admin
  ISSUE_RESOLVED // Executive resolves issue -> Admin
  ADMIN_COMMENT_ADDED // Admin adds comment -> Executive
  SYSTEM_ANNOUNCEMENT // System-wide announcements
  VISIT_PLAN_SUBMITTED // Executive submits a PJP/visit plan -> Admin
  VISIT_PLAN_ASSIGNED // Admin assigns visit plan to Executive -> Executive
}

enum NotificationStatus {
  UNREAD
  READ
  ARCHIVED
}

enum NotificationPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model Notification {
  id       String               @id @default(auto()) @map("_id") @db.ObjectId
  title    String // Short notification title
  message  String // Detailed notification message
  type     NotificationType // Type of notification
  status   NotificationStatus   @default(UNREAD)
  priority NotificationPriority @default(MEDIUM)

  // Recipient information
  recipientId   String // User ID who receives the notification
  recipientRole Role // ADMIN or EXECUTIVE

  // Sender information (optional for system notifications)
  senderId   String? // User ID who triggered the notification
  senderRole Role? // ADMIN or EXECUTIVE

  // Related entity references (for deep linking)
  visitId     String? @db.ObjectId // Related visit ID
  issueId     String? // Related issue ID
  assignedId  String? @db.ObjectId // Related assignment ID
  visitPlanId String? @db.ObjectId // Related visit plan (PJP) ID

  // Metadata
  metadata  Json? // Additional contextual data
  actionUrl String? // Deep link to related page

  // Timestamps
  createdAt  DateTime  @default(now())
  readAt     DateTime? // When notification was read
  archivedAt DateTime? // When notification was archived
  expiresAt  DateTime? // Optional expiration for temporary notifications

  // Relations (optional - for referential integrity)
  visit     Visit?     @relation(fields: [visitId], references: [id])
  issue     Issue?     @relation(fields: [issueId], references: [id])
  assigned  Assigned?  @relation(fields: [assignedId], references: [id])
  visitPlan VisitPlan? @relation(fields: [visitPlanId], references: [id])

  // Indexes for performance
  @@index([recipientId, status, createdAt])
  @@index([type, createdAt])
  @@index([recipientId, recipientRole])
  @@map("Notification")
}

// Dost chat memory
//
model DostChat {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  question     String
  answerText   String?
  payload      Json?
  executiveId  String
  userId       String
  createdAt    DateTime @default(now())

  executive    Executive @relation(fields: [executiveId], references: [id])
  user         User      @relation(fields: [userId], references: [id])

  @@index([executiveId, createdAt])
  @@map("DostChat")
}

// Holiday Management
//
model Holiday {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  date        DateTime // Holiday date (stored as UTC date)
  name        String?  // Optional holiday name (e.g., "Christmas", "New Year")
  description String?  // Optional description
  isRecurring Boolean  @default(false) // Whether this holiday repeats yearly
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?  // Admin ID who created this holiday
  
  // Index for efficient date lookups
  @@index([date])
  @@map("Holiday")
}
